# -*- coding: utf-8 -*-
"""Lotofácil.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWyeB6xRg-NIxV9w-_zxTHgfFVTOZd2N

# Análise Exploratória Lotofácil

A Lotofácil foi criada pela Caixa Econômica Federal em 29 de setembro de 2003 como uma loteria mais acessível que a Mega-Sena.
A ideia era oferecer uma modalidade com probabilidade maior de acerto, já que o jogador marca 15 a 20 números dentre 25 disponíveis, e sempre são sorteados 15 números.

## Linha do tempo da Lotofácil

* 2003 (criação):
  * Primeiro sorteio em 29/09/2003;
  * Inicialmente os sorteios eram duas vezes por semana (segundas e quintas).

* 2008:
  * Expansão: passou a ter três sorteios por semana (segundas, quartas e sextas).

* 2014:
  * Introdução do concurso especial de **Lotofácil da Independência**, realizado todo 7 de setembro ou no sábado mais próximo. Esse concurso não acumula (o prêmio é todo distribuído no próprio sorteio).

* 2019:
  * Frequência aumentada e passou a ter seis sorteios por semana (segunda a sábado).

* 2020 em diante:
  * Virou praticamente diária, com sorteios de segunda a sábado;
  * Apostas passaram a poder marcar até 20 dezenas (antes eram só 15).

* Situação atual (2025):
  * Sorteios de segunda a sábado (6 vezes por semana, exceto domingos e feriados bancários).
  * Valor da aposta mínima (15 números) gira em torno de R$ 3,50;
  * Concurso especial Lotofácil da Independência continua acontecendo todo ano em setembro.
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots

!ls -lh /content/drive/MyDrive/Projetos/Loterias/Lotofácil.xlsx

from google.colab import drive
drive.mount('/content/drive')

# Caminho do arquivo que você já tem no Colab
file_path = "/content/drive/MyDrive/Projetos/Loterias/Lotofacil/Lotofácil.xlsx"

# Leitura do arquivo Excel
df = pd.read_excel(file_path)

# Exibir dimensões e primeiras linhas para confirmar
print(df.shape)
df.head()

df.info()

df.columns

# Subconjunto de colunas
cols = ['Concurso', 'Data Sorteio', 'Bola1', 'Bola2', 'Bola3', 'Bola4', 'Bola5',
       'Bola6', 'Bola7', 'Bola8', 'Bola9', 'Bola10', 'Bola11', 'Bola12',
       'Bola13', 'Bola14', 'Bola15', 'Ganhadores 15 acertos', 'Cidade / UF',
       'Rateio 15 acertos']
df_sel = df.loc[:, cols].copy()
df_sel.head(25)

# Renomear a coluna "Data Sorteio" para apenas "Data"
df_sel = df_sel.rename(columns={
    "Data Sorteio": "Data",
    "Ganhadores 15 acertos": "Ganhadores_15",
    "Rateio 15 acertos": "Rateio_15",
    "Cidade / UF": "UF"

    })

df_sel.head()

# Verificar se o subconjunto foi criado corretamente
print(df_sel.shape)          # dimensões do novo DataFrame
print(df_sel.dtypes)         # tipos das colunas

# Criar colunas de data após renomear "Data Sorteio" para "Data"
# Converter para datetime
df_sel["Data"] = pd.to_datetime(df_sel["Data"], dayfirst=True, errors="coerce")

# Criar colunas separadas de dia, mês e ano
df_sel["Dia"] = df_sel["Data"].dt.day
df_sel["Mes"] = df_sel["Data"].dt.month
df_sel["Ano"] = df_sel["Data"].dt.year

# Criar coluna com o dia da semana (em inglês por padrão)
df_sel["DiaSemana"] = df_sel["Data"].dt.day_name()

# Traduzir os dias da semana manualmente para português
traducao_dias = {
    "Monday": "Segunda-feira",
    "Tuesday": "Terça-feira",
    "Wednesday": "Quarta-feira",
    "Thursday": "Quinta-feira",
    "Friday": "Sexta-feira",
    "Saturday": "Sábado",
    "Sunday": "Domingo"
}
df_sel["DiaSemana"] = df_sel["DiaSemana"].replace(traducao_dias)

# Visualizar resultado
df_sel.head(10)

# Função de verificação de valores estranhos ao Dataframe
def diagnostica_vazios(df):
    resultado = []

    for col in df.columns:
        tipo = str(df[col].dtype)
        total_linhas = len(df)
        nulos = df[col].isnull().sum()
        vazios = 0
        espacos = 0
        zeros = 0
        total_vazios = nulos  # vai ser atualizado conforme o tipo

        # Diagnóstico para colunas texto
        if tipo in ['object', 'string']:
            vazios = (df[col] == '').sum()
            espacos = (df[col].astype(str).str.strip() == '').sum()
            total_vazios = nulos + espacos

        # Diagnóstico para colunas numéricas
        elif 'int' in tipo or 'float' in tipo:
            zeros = (df[col] == 0).sum()
            total_vazios = nulos + zeros

        resultado.append({
            'coluna': col,
            'tipo': tipo,
            'nulos': nulos,
            'vazios': vazios,
            'espacos': espacos,
            'zeros': zeros,
            'total_vazios': total_vazios,
            'percentual_nulos': round(nulos / total_linhas * 100, 2),
            'percentual_zeros': round(zeros / total_linhas * 100, 2) if zeros > 0 else 0
        })

    diagnostico_df = pd.DataFrame(resultado)
    diagnostico_df = diagnostico_df.sort_values(by='total_vazios', ascending=False)

    return diagnostico_df

# Exibir

diagnostico = diagnostica_vazios(df_sel)
display(diagnostico)

"""## Análise Temporal

### 1.1. Gráfico de barras dos sorteios geral, por ano, mês e dia de semana
"""

# ============================================================
# Barras de contagem por Número (Geral, por Ano, por Mês, por DiaSemana)
# Pré-requisitos: df_long com colunas ['Numero','Ano','Mes','DiaSemana'] e ord_num = [1..25]
# ============================================================

# ------------------------------------------------------------
# Helper para escrever valores nas barras (dentro, em branco e vertical)
# ------------------------------------------------------------
def anotar_barras(ax, fmt="%.0f", fontsize=8):
    for cont in ax.containers:
        ax.bar_label(
            cont, fmt=fmt, label_type="center",
            fontsize=fontsize, color="white", rotation=90
        )

def anotar_em_facet(g, fmt="%.0f", fontsize=7):
    g.figure.canvas.draw_idle()
    for ax in g.axes.flatten():
        anotar_barras(ax, fmt=fmt, fontsize=fontsize)


cont_total = (
    df_long["Numero"].astype(int)
           .value_counts(sort=False)
           .reindex(ord_num, fill_value=0)
           .rename_axis("Numero")
           .reset_index(name="freq")
)

fig, ax = plt.subplots(figsize=(14, 5))
sns.barplot(data=cont_total, x="Numero", y="freq", color="tab:blue", ax=ax, order=ord_num)
anotar_barras(ax, fmt="%.0f", fontsize=8)
ax.set_title("Contagem total de aparições por Número (Geral)")
ax.set_xlabel("Número")
ax.set_ylabel("Frequência")
plt.tight_layout()
plt.show()

"""### 1.2. Heatmap de frequência de sorteios por ano, mês e dia de semana"""

# Garantir tipos e valores válidos para as bolas (1..25)
col_bolas = [f"Bola{i}" for i in range(1, 16)]
for c in col_bolas:
    df_sel[c] = pd.to_numeric(df_sel[c], errors="coerce")

# -----------------------------------------------
# Transformação para formato longo (uma bola por linha)
# -----------------------------------------------
id_cols = ["Concurso", "Data", "Ano", "Mes", "Dia", "DiaSemana"]
df_long = (
    df_sel[id_cols + col_bolas]
      .melt(id_vars=id_cols, value_vars=col_bolas,
            var_name="Posicao", value_name="Numero")
      .dropna(subset=["Numero"])
)

df_long["Numero"] = df_long["Numero"].astype(int)
# -----------------------------------------------
# Ordenações/categorias para manter os eixos consistentes
# -----------------------------------------------
# Ordem dos números da Lotofácil
ord_num = list(range(1, 26))
df_long["Numero"] = pd.Categorical(df_long["Numero"], categories=ord_num, ordered=True)

# Ordem dos meses (1..12)
ord_mes = list(range(1, 13))
df_long["Mes"] = pd.Categorical(df_long["Mes"], categories=ord_mes, ordered=True)

# Ordem dos dias da semana
ord_semana = [
    "Segunda-feira", "Terça-feira", "Quarta-feira",
    "Quinta-feira", "Sexta-feira", "Sábado", "Domingo"
]
# Se houver acentuação/variação, normaliza para a categoria mais próxima
df_long["DiaSemana"] = df_long["DiaSemana"].astype(str)
df_long["DiaSemana"] = pd.Categorical(df_long["DiaSemana"], categories=ord_semana, ordered=True)

# -----------------------------------------------
# Tabelas de frequência (absoluta)
# -----------------------------------------------
# Por ano
tabela_freq_ano = (
    df_long.groupby(["Numero", "Ano"], observed=True)
           .size()
           .unstack("Ano", fill_value=0)
           .reindex(index=ord_num)
)

# Por mês (todos os anos combinados)
tabela_freq_mes = (
    df_long.groupby(["Numero", "Mes"], observed=True)
           .size()
           .unstack("Mes", fill_value=0)
           .reindex(index=ord_num)
           .reindex(columns=ord_mes, fill_value=0)
)

# Por dia da semana (todos os anos combinados)
tabela_freq_semana = (
    df_long.groupby(["Numero", "DiaSemana"], observed=True)
           .size()
           .unstack("DiaSemana", fill_value=0)
           .reindex(index=ord_num)
           .reindex(columns=ord_semana, fill_value=0)
)

# -----------------------------------------------
# Visualizações (3 heatmaps)
# -----------------------------------------------
plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_freq_ano,
    cmap="YlGnBu",
    annot=True,       # defina True se quiser números escritos nas células
    fmt=".0f",
    cbar_kws={"label": "Frequência"}
)
plt.title("Frequência de cada número da Lotofácil por Ano")
plt.ylabel("Número")
plt.xlabel("Ano")
plt.tight_layout()
plt.show()

plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_freq_mes,
    cmap="YlGnBu",
    annot=True,
    fmt=".0f",
    cbar_kws={"label": "Frequência"}
)
plt.title("Frequência de cada número da Lotofácil por Mês (todos os anos)")
plt.ylabel("Número")
plt.xlabel("Mês")
plt.tight_layout()
plt.show()

plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_freq_semana,
    cmap="YlGnBu",
    annot=True,
    fmt=".0f",
    cbar_kws={"label": "Frequência"}
)
plt.title("Frequência de cada número da Lotofácil por Dia da Semana (todos os anos)")
plt.ylabel("Número")
plt.xlabel("Dia da Semana")
plt.tight_layout()
plt.show()

# ---------------------------------------------------
# Frequência relativa (%) por coluna
# ---------------------------------------------------

# Frequência relativa por ano (coluna soma = 100%)
tabela_rel_ano = tabela_freq_ano.div(tabela_freq_ano.sum(axis=0), axis=1) * 100

# Frequência relativa por mês (coluna soma = 100%)
tabela_rel_mes = tabela_freq_mes.div(tabela_freq_mes.sum(axis=0), axis=1) * 100

# Frequência relativa por dia da semana (coluna soma = 100%)
tabela_rel_semana = tabela_freq_semana.div(tabela_freq_semana.sum(axis=0), axis=1) * 100

# ---------------------------------------------------
# Heatmaps das frequências relativas
# ---------------------------------------------------

plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_rel_ano,
    cmap="YlOrBr",
    annot=True,       # mostra valores na célula
    fmt=".1f",        # 1 casa decimal
    cbar_kws={"label": "% dentro do Ano"}
)
plt.title("Frequência relativa (%) de cada número da Lotofácil por Ano")
plt.ylabel("Número")
plt.xlabel("Ano")
plt.tight_layout()
plt.show()

plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_rel_mes,
    cmap="YlOrBr",
    annot=True,
    fmt=".1f",
    cbar_kws={"label": "% dentro do Mês"}
)
plt.title("Frequência relativa (%) de cada número da Lotofácil por Mês (todos os anos)")
plt.ylabel("Número")
plt.xlabel("Mês")
plt.tight_layout()
plt.show()

plt.figure(figsize=(18, 8))
sns.heatmap(
    tabela_rel_semana,
    cmap="YlOrBr",
    annot=True,
    fmt=".1f",
    cbar_kws={"label": "% dentro do Dia da Semana"}
)
plt.title("Frequência relativa (%) de cada número da Lotofácil por Dia da Semana (todos os anos)")
plt.ylabel("Número")
plt.xlabel("Dia da Semana")
plt.tight_layout()
plt.show()

"""Na Lotofácil, em cada sorteio são escolhidos 15 números entre 25 possíveis.
Ou seja, a chance teórica de qualquer número aparecer em um sorteio é:
* 15/25 = 0,6

Isso significa que, se o sorteio for perfeitamente aleatório, cada número deveria aparecer em torno de 60% dos concursos de um ano.

Então, normalizei e comparei com 0.6, a ideia foi:
* Probabilidade observada = frequência real de cada número em um ano / nº de sorteios daquele ano.
* Probabilidade teórica (0.6) = expectativa ideal.
"""

# ===================================================
# Probabilidade por sorteio (normalizada pelo nº de concursos no período)
# Reusa: df_sel, tabela_freq_ano, tabela_freq_mes, tabela_freq_semana, ord_mes, ord_semana
# Interpretação: média de vezes que o número aparece por concurso no período
# Esperado teórico ≈ 15/25 = 0.60
# ===================================================

# -----------------------------
# nº de concursos por período
# -----------------------------
n_sorteios_ano = df_sel.groupby("Ano")["Concurso"].nunique()
n_sorteios_mes = df_sel.groupby("Mes")["Concurso"].nunique()
n_sorteios_sem = df_sel.groupby("DiaSemana")["Concurso"].nunique()

# alinhar índices/ordem às tabelas já existentes e evitar divisão por zero
n_sorteios_ano = n_sorteios_ano.reindex(tabela_freq_ano.columns).replace(0, np.nan)
n_sorteios_mes = n_sorteios_mes.reindex(tabela_freq_mes.columns).replace(0, np.nan)
n_sorteios_sem = n_sorteios_sem.reindex(tabela_freq_semana.columns).replace(0, np.nan)

# -----------------------------
# probabilidade por sorteio
# -----------------------------
tabela_prob_ano = tabela_freq_ano.div(n_sorteios_ano, axis=1).fillna(0.0)
tabela_prob_mes = tabela_freq_mes.div(n_sorteios_mes, axis=1).fillna(0.0).reindex(columns=ord_mes, fill_value=0.0)
tabela_prob_sem = tabela_freq_semana.div(n_sorteios_sem, axis=1).fillna(0.0).reindex(columns=ord_semana, fill_value=0.0)

# -----------------------------
# função de plot para reduzir repetição
# -----------------------------
def plot_heatmap(df, titulo, label_cbar, vmin=0, vmax=1, fmt=".2f"):
    plt.figure(figsize=(18, 8))
    sns.heatmap(
        df, cmap="YlGnBu", annot=True, fmt=fmt,
        vmin=vmin, vmax=vmax, cbar_kws={"label": label_cbar}
    )
    plt.title(titulo)
    plt.ylabel("Número")
    plt.tight_layout()
    plt.show()

# -----------------------------
# gráficos (probabilidade por sorteio)
# -----------------------------
plot_heatmap(tabela_prob_ano, "Probabilidade por sorteio — por Ano", "Probabilidade", vmin=0, vmax=1, fmt=".2f")
plot_heatmap(tabela_prob_mes, "Probabilidade por sorteio — por Mês (todos os anos)", "Probabilidade", vmin=0, vmax=1, fmt=".2f")
plot_heatmap(tabela_prob_sem, "Probabilidade por sorteio — por Dia da Semana (todos os anos)", "Probabilidade", vmin=0, vmax=1, fmt=".2f")

# -----------------------------
# (Opcional) Excesso vs. expectativa teórica (~0,60)
# Útil para destacar acima/abaixo do esperado
# -----------------------------
ESP = 15 / 25  # 0.60
excesso_ano = tabela_prob_ano - ESP
excesso_mes = tabela_prob_mes - ESP
excesso_sem = tabela_prob_sem - ESP

plot_heatmap(excesso_ano, "Excesso vs. 0,60 — por Ano", "Δ prob.", vmin=-0.10, vmax=0.10, fmt="+.2f")
plot_heatmap(excesso_mes, "Excesso vs. 0,60 — por Mês", "Δ prob.", vmin=-0.10, vmax=0.10, fmt="+.2f")
plot_heatmap(excesso_sem, "Excesso vs. 0,60 — por Dia da Semana", "Δ prob.", vmin=-0.10, vmax=0.10, fmt="+.2f")

# ============================================================
# Heatmaps mensais - Probabilidade por sorteio combinando Mês × Dia da Semana
# ============================================================

# ------------------------------------------------------------
# Calcula probabilidade por sorteio em (Mes, DiaSemana, Numero)
#   prob = freq(num|Mes,DiaSemana) / n_concursos(Mes,DiaSemana)
# ------------------------------------------------------------
# n° de concursos por (Mes, DiaSemana)
n_sorteios_mes_sem = (
    df_sel.groupby(["Mes", "DiaSemana"])["Concurso"]
          .nunique()
          .rename("n_sorteios")
          .reset_index()
)

# frequência por (Mes, DiaSemana, Numero) usando df_long já pronto
freq_mes_sem_num = (
    df_long.groupby(["Mes", "DiaSemana", "Numero"], observed=True)
           .size()
           .reset_index(name="freq")
)

# junta e calcula probabilidade
base_mes_sem = freq_mes_sem_num.merge(n_sorteios_mes_sem, on=["Mes", "DiaSemana"], how="left")
base_mes_sem["prob"] = np.where(base_mes_sem["n_sorteios"].gt(0),
                                base_mes_sem["freq"] / base_mes_sem["n_sorteios"], 0.0)

# ------------------------------------------------------------
# Função: tabela para um mês m (linhas=Numero, colunas=DiaSemana)
# ------------------------------------------------------------
def tabela_prob_do_mes(m):
    sub = base_mes_sem[base_mes_sem["Mes"] == m].copy()
    tabela = (
        sub.pivot(index="Numero", columns="DiaSemana", values="prob")
           .reindex(index=ord_num)
           .reindex(columns=ord_semana, fill_value=0.0)
           .fillna(0.0)
    )
    return tabela

# ------------------------------------------------------------
# Plot em grade 3x4 (um painel por mês) com escala fixa (0..1)
# Ajuste vmin/vmax se desejar realçar contraste
# ------------------------------------------------------------
fig, axes = plt.subplots(3, 4, figsize=(26, 16), sharex=False, sharey=True)
axes = axes.ravel()

vmin, vmax = 0.0, 1.0        # faixa fixa para comparação entre meses
fmt_celula = ".2f"           # duas casas na célula
cbar_ax = fig.add_axes([0.92, 0.15, 0.015, 0.7])  # eixo da barra de cores compartilhada

# constrói a matriz concatenada para calibrar a colorbar (mesma escala)
# (não é obrigatório, mas deixa a colorbar consistente)
all_blocks = []
for m in ord_mes:
    t = tabela_prob_do_mes(m)
    if t is not None and t.shape[1] > 0:
        all_blocks.append(t.values)
if len(all_blocks) == 0:
    raise ValueError("Não há dados para os meses informados.")
_ = np.concatenate(all_blocks, axis=1)

# desenha painéis
for idx, m in enumerate(ord_mes):
    ax = axes[idx]
    tab = tabela_prob_do_mes(m)
    im = ax.imshow(tab.values, aspect="auto", vmin=vmin, vmax=vmax)

    # rótulos dos eixos
    ax.set_title(f"Mês {m:02d}")
    ax.set_yticks(np.arange(tab.shape[0]))
    ax.set_yticklabels(tab.index.astype(int))
    ax.set_xticks(np.arange(tab.shape[1]))
    ax.set_xticklabels(tab.columns, rotation=45, ha="right")

    # anotações (opcional: comente se ficar pesado)
    for i in range(tab.shape[0]):
        for j in range(tab.shape[1]):
            v = tab.values[i, j]
            if v > 0:
                ax.text(j, i, format(v, fmt_celula), ha="center", va="center", fontsize=6)

# remove eixos extras caso haja menos que 12 meses presentes
for k in range(len(ord_mes), len(axes)):
    fig.delaxes(axes[k])

# colorbar compartilhada
cb = fig.colorbar(im, cax=cbar_ax)
cb.set_label("Probabilidade por sorteio")

fig.suptitle("Probabilidade por sorteio — Número × Dia da Semana (um heatmap por mês)", y=0.98, fontsize=16)
plt.tight_layout(rect=[0.02, 0.03, 0.90, 0.96])
plt.show()

# ============================================================
# Heatmap de probabilidade por sorteio para UM mês específico
# ============================================================

mes_escolhido = 8   # <-- altere aqui (1=Jan, 2=Fev, ..., 12=Dez)

# gera a tabela (linhas = Número, colunas = Dia da Semana)
tabela_mes = tabela_prob_do_mes(mes_escolhido)

plt.figure(figsize=(12, 8))
sns.heatmap(
    tabela_mes,
    cmap="YlGnBu",
    annot=True,
    fmt=".2f",
    vmin=0, vmax=1,
    cbar_kws={"label": "Probabilidade por sorteio"}
)
plt.title(f"Probabilidade por sorteio — Números × Dia da Semana (Mês {mes_escolhido:02d})")
plt.ylabel("Número")
plt.xlabel("Dia da Semana")
plt.tight_layout()
plt.show()